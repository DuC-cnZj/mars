// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/duc-cnzj/mars/api/v4/mars"
	"github.com/duc-cnzj/mars/api/v4/types"
	"github.com/duc-cnzj/mars/v4/internal/ent/accesstoken"
	"github.com/duc-cnzj/mars/v4/internal/ent/cachelock"
	"github.com/duc-cnzj/mars/v4/internal/ent/changelog"
	"github.com/duc-cnzj/mars/v4/internal/ent/dbcache"
	"github.com/duc-cnzj/mars/v4/internal/ent/event"
	"github.com/duc-cnzj/mars/v4/internal/ent/file"
	"github.com/duc-cnzj/mars/v4/internal/ent/gitproject"
	"github.com/duc-cnzj/mars/v4/internal/ent/namespace"
	"github.com/duc-cnzj/mars/v4/internal/ent/predicate"
	"github.com/duc-cnzj/mars/v4/internal/ent/project"
	"github.com/duc-cnzj/mars/v4/internal/ent/schema/schematype"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessToken = "AccessToken"
	TypeCacheLock   = "CacheLock"
	TypeChangelog   = "Changelog"
	TypeDBCache     = "DBCache"
	TypeEvent       = "Event"
	TypeFile        = "File"
	TypeGitProject  = "GitProject"
	TypeNamespace   = "Namespace"
	TypeProject     = "Project"
)

// AccessTokenMutation represents an operation that mutates the AccessToken nodes in the graph.
type AccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	usage         *string
	email         *string
	expired_at    *time.Time
	last_used_at  *time.Time
	user_info     *schematype.UserInfo
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AccessToken, error)
	predicates    []predicate.AccessToken
}

var _ ent.Mutation = (*AccessTokenMutation)(nil)

// accesstokenOption allows management of the mutation configuration using functional options.
type accesstokenOption func(*AccessTokenMutation)

// newAccessTokenMutation creates new mutation for the AccessToken entity.
func newAccessTokenMutation(c config, op Op, opts ...accesstokenOption) *AccessTokenMutation {
	m := &AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokenID sets the ID field of the mutation.
func withAccessTokenID(id int) accesstokenOption {
	return func(m *AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessToken
		)
		m.oldValue = func(ctx context.Context) (*AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessToken sets the old AccessToken of the mutation.
func withAccessToken(node *AccessToken) accesstokenOption {
	return func(m *AccessTokenMutation) {
		m.oldValue = func(context.Context) (*AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccessTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccessTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccessTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[accesstoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccessTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccessTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, accesstoken.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *AccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AccessTokenMutation) ResetToken() {
	m.token = nil
}

// SetUsage sets the "usage" field.
func (m *AccessTokenMutation) SetUsage(s string) {
	m.usage = &s
}

// Usage returns the value of the "usage" field in the mutation.
func (m *AccessTokenMutation) Usage() (r string, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUsage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// ResetUsage resets all changes to the "usage" field.
func (m *AccessTokenMutation) ResetUsage() {
	m.usage = nil
}

// SetEmail sets the "email" field.
func (m *AccessTokenMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccessTokenMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccessTokenMutation) ResetEmail() {
	m.email = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *AccessTokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *AccessTokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *AccessTokenMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[accesstoken.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *AccessTokenMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *AccessTokenMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, accesstoken.FieldExpiredAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AccessTokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AccessTokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AccessTokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[accesstoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AccessTokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AccessTokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, accesstoken.FieldLastUsedAt)
}

// SetUserInfo sets the "user_info" field.
func (m *AccessTokenMutation) SetUserInfo(si schematype.UserInfo) {
	m.user_info = &si
}

// UserInfo returns the value of the "user_info" field in the mutation.
func (m *AccessTokenMutation) UserInfo() (r schematype.UserInfo, exists bool) {
	v := m.user_info
	if v == nil {
		return
	}
	return *v, true
}

// OldUserInfo returns the old "user_info" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUserInfo(ctx context.Context) (v schematype.UserInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserInfo: %w", err)
	}
	return oldValue.UserInfo, nil
}

// ClearUserInfo clears the value of the "user_info" field.
func (m *AccessTokenMutation) ClearUserInfo() {
	m.user_info = nil
	m.clearedFields[accesstoken.FieldUserInfo] = struct{}{}
}

// UserInfoCleared returns if the "user_info" field was cleared in this mutation.
func (m *AccessTokenMutation) UserInfoCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldUserInfo]
	return ok
}

// ResetUserInfo resets all changes to the "user_info" field.
func (m *AccessTokenMutation) ResetUserInfo() {
	m.user_info = nil
	delete(m.clearedFields, accesstoken.FieldUserInfo)
}

// Where appends a list predicates to the AccessTokenMutation builder.
func (m *AccessTokenMutation) Where(ps ...predicate.AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessToken).
func (m *AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, accesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accesstoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, accesstoken.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, accesstoken.FieldToken)
	}
	if m.usage != nil {
		fields = append(fields, accesstoken.FieldUsage)
	}
	if m.email != nil {
		fields = append(fields, accesstoken.FieldEmail)
	}
	if m.expired_at != nil {
		fields = append(fields, accesstoken.FieldExpiredAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, accesstoken.FieldLastUsedAt)
	}
	if m.user_info != nil {
		fields = append(fields, accesstoken.FieldUserInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case accesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case accesstoken.FieldDeletedAt:
		return m.DeletedAt()
	case accesstoken.FieldToken:
		return m.Token()
	case accesstoken.FieldUsage:
		return m.Usage()
	case accesstoken.FieldEmail:
		return m.Email()
	case accesstoken.FieldExpiredAt:
		return m.ExpiredAt()
	case accesstoken.FieldLastUsedAt:
		return m.LastUsedAt()
	case accesstoken.FieldUserInfo:
		return m.UserInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accesstoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accesstoken.FieldToken:
		return m.OldToken(ctx)
	case accesstoken.FieldUsage:
		return m.OldUsage(ctx)
	case accesstoken.FieldEmail:
		return m.OldEmail(ctx)
	case accesstoken.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case accesstoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case accesstoken.FieldUserInfo:
		return m.OldUserInfo(ctx)
	}
	return nil, fmt.Errorf("unknown AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accesstoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case accesstoken.FieldUsage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case accesstoken.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case accesstoken.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case accesstoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case accesstoken.FieldUserInfo:
		v, ok := value.(schematype.UserInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserInfo(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accesstoken.FieldDeletedAt) {
		fields = append(fields, accesstoken.FieldDeletedAt)
	}
	if m.FieldCleared(accesstoken.FieldExpiredAt) {
		fields = append(fields, accesstoken.FieldExpiredAt)
	}
	if m.FieldCleared(accesstoken.FieldLastUsedAt) {
		fields = append(fields, accesstoken.FieldLastUsedAt)
	}
	if m.FieldCleared(accesstoken.FieldUserInfo) {
		fields = append(fields, accesstoken.FieldUserInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokenMutation) ClearField(name string) error {
	switch name {
	case accesstoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case accesstoken.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case accesstoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case accesstoken.FieldUserInfo:
		m.ClearUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokenMutation) ResetField(name string) error {
	switch name {
	case accesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accesstoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accesstoken.FieldToken:
		m.ResetToken()
		return nil
	case accesstoken.FieldUsage:
		m.ResetUsage()
		return nil
	case accesstoken.FieldEmail:
		m.ResetEmail()
		return nil
	case accesstoken.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case accesstoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case accesstoken.FieldUserInfo:
		m.ResetUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccessToken edge %s", name)
}

// CacheLockMutation represents an operation that mutates the CacheLock nodes in the graph.
type CacheLockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	owner         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CacheLock, error)
	predicates    []predicate.CacheLock
}

var _ ent.Mutation = (*CacheLockMutation)(nil)

// cachelockOption allows management of the mutation configuration using functional options.
type cachelockOption func(*CacheLockMutation)

// newCacheLockMutation creates new mutation for the CacheLock entity.
func newCacheLockMutation(c config, op Op, opts ...cachelockOption) *CacheLockMutation {
	m := &CacheLockMutation{
		config:        c,
		op:            op,
		typ:           TypeCacheLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCacheLockID sets the ID field of the mutation.
func withCacheLockID(id int) cachelockOption {
	return func(m *CacheLockMutation) {
		var (
			err   error
			once  sync.Once
			value *CacheLock
		)
		m.oldValue = func(ctx context.Context) (*CacheLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CacheLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCacheLock sets the old CacheLock of the mutation.
func withCacheLock(node *CacheLock) cachelockOption {
	return func(m *CacheLockMutation) {
		m.oldValue = func(context.Context) (*CacheLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CacheLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CacheLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CacheLockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CacheLockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CacheLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *CacheLockMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CacheLockMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *CacheLockMutation) ResetKey() {
	m.key = nil
}

// SetOwner sets the "owner" field.
func (m *CacheLockMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *CacheLockMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *CacheLockMutation) ResetOwner() {
	m.owner = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *CacheLockMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *CacheLockMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *CacheLockMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[cachelock.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *CacheLockMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[cachelock.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *CacheLockMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, cachelock.FieldExpiredAt)
}

// Where appends a list predicates to the CacheLockMutation builder.
func (m *CacheLockMutation) Where(ps ...predicate.CacheLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CacheLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CacheLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CacheLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CacheLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CacheLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CacheLock).
func (m *CacheLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CacheLockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, cachelock.FieldKey)
	}
	if m.owner != nil {
		fields = append(fields, cachelock.FieldOwner)
	}
	if m.expired_at != nil {
		fields = append(fields, cachelock.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CacheLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cachelock.FieldKey:
		return m.Key()
	case cachelock.FieldOwner:
		return m.Owner()
	case cachelock.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CacheLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cachelock.FieldKey:
		return m.OldKey(ctx)
	case cachelock.FieldOwner:
		return m.OldOwner(ctx)
	case cachelock.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown CacheLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CacheLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cachelock.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case cachelock.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case cachelock.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown CacheLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CacheLockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CacheLockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CacheLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CacheLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CacheLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cachelock.FieldExpiredAt) {
		fields = append(fields, cachelock.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CacheLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CacheLockMutation) ClearField(name string) error {
	switch name {
	case cachelock.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CacheLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CacheLockMutation) ResetField(name string) error {
	switch name {
	case cachelock.FieldKey:
		m.ResetKey()
		return nil
	case cachelock.FieldOwner:
		m.ResetOwner()
		return nil
	case cachelock.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CacheLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CacheLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CacheLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CacheLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CacheLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CacheLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CacheLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CacheLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CacheLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CacheLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CacheLock edge %s", name)
}

// ChangelogMutation represents an operation that mutates the Changelog nodes in the graph.
type ChangelogMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	version                  *int
	addversion               *int
	username                 *string
	manifest                 *[]string
	appendmanifest           []string
	_config                  *string
	config_type              *string
	git_branch               *string
	git_commit               *string
	docker_image             *[]string
	appenddocker_image       []string
	env_values               *[]*types.KeyValue
	appendenv_values         []*types.KeyValue
	extra_values             *[]*types.ExtraValue
	appendextra_values       []*types.ExtraValue
	final_extra_values       *[]string
	appendfinal_extra_values []string
	git_commit_web_url       *string
	git_commit_title         *string
	git_commit_author        *string
	git_commit_date          *time.Time
	config_changed           *bool
	clearedFields            map[string]struct{}
	git_project              *int
	clearedgit_project       bool
	project                  *int
	clearedproject           bool
	done                     bool
	oldValue                 func(context.Context) (*Changelog, error)
	predicates               []predicate.Changelog
}

var _ ent.Mutation = (*ChangelogMutation)(nil)

// changelogOption allows management of the mutation configuration using functional options.
type changelogOption func(*ChangelogMutation)

// newChangelogMutation creates new mutation for the Changelog entity.
func newChangelogMutation(c config, op Op, opts ...changelogOption) *ChangelogMutation {
	m := &ChangelogMutation{
		config:        c,
		op:            op,
		typ:           TypeChangelog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangelogID sets the ID field of the mutation.
func withChangelogID(id int) changelogOption {
	return func(m *ChangelogMutation) {
		var (
			err   error
			once  sync.Once
			value *Changelog
		)
		m.oldValue = func(ctx context.Context) (*Changelog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Changelog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChangelog sets the old Changelog of the mutation.
func withChangelog(node *Changelog) changelogOption {
	return func(m *ChangelogMutation) {
		m.oldValue = func(context.Context) (*Changelog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangelogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangelogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangelogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangelogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Changelog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangelogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangelogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangelogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangelogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangelogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangelogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChangelogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChangelogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChangelogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[changelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChangelogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[changelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChangelogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, changelog.FieldDeletedAt)
}

// SetVersion sets the "version" field.
func (m *ChangelogMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ChangelogMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ChangelogMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ChangelogMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ChangelogMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetUsername sets the "username" field.
func (m *ChangelogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ChangelogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ChangelogMutation) ResetUsername() {
	m.username = nil
}

// SetManifest sets the "manifest" field.
func (m *ChangelogMutation) SetManifest(s []string) {
	m.manifest = &s
	m.appendmanifest = nil
}

// Manifest returns the value of the "manifest" field in the mutation.
func (m *ChangelogMutation) Manifest() (r []string, exists bool) {
	v := m.manifest
	if v == nil {
		return
	}
	return *v, true
}

// OldManifest returns the old "manifest" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldManifest(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifest: %w", err)
	}
	return oldValue.Manifest, nil
}

// AppendManifest adds s to the "manifest" field.
func (m *ChangelogMutation) AppendManifest(s []string) {
	m.appendmanifest = append(m.appendmanifest, s...)
}

// AppendedManifest returns the list of values that were appended to the "manifest" field in this mutation.
func (m *ChangelogMutation) AppendedManifest() ([]string, bool) {
	if len(m.appendmanifest) == 0 {
		return nil, false
	}
	return m.appendmanifest, true
}

// ClearManifest clears the value of the "manifest" field.
func (m *ChangelogMutation) ClearManifest() {
	m.manifest = nil
	m.appendmanifest = nil
	m.clearedFields[changelog.FieldManifest] = struct{}{}
}

// ManifestCleared returns if the "manifest" field was cleared in this mutation.
func (m *ChangelogMutation) ManifestCleared() bool {
	_, ok := m.clearedFields[changelog.FieldManifest]
	return ok
}

// ResetManifest resets all changes to the "manifest" field.
func (m *ChangelogMutation) ResetManifest() {
	m.manifest = nil
	m.appendmanifest = nil
	delete(m.clearedFields, changelog.FieldManifest)
}

// SetConfig sets the "config" field.
func (m *ChangelogMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *ChangelogMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ChangelogMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[changelog.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ChangelogMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[changelog.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ChangelogMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, changelog.FieldConfig)
}

// SetConfigType sets the "config_type" field.
func (m *ChangelogMutation) SetConfigType(s string) {
	m.config_type = &s
}

// ConfigType returns the value of the "config_type" field in the mutation.
func (m *ChangelogMutation) ConfigType() (r string, exists bool) {
	v := m.config_type
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigType returns the old "config_type" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldConfigType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigType: %w", err)
	}
	return oldValue.ConfigType, nil
}

// ClearConfigType clears the value of the "config_type" field.
func (m *ChangelogMutation) ClearConfigType() {
	m.config_type = nil
	m.clearedFields[changelog.FieldConfigType] = struct{}{}
}

// ConfigTypeCleared returns if the "config_type" field was cleared in this mutation.
func (m *ChangelogMutation) ConfigTypeCleared() bool {
	_, ok := m.clearedFields[changelog.FieldConfigType]
	return ok
}

// ResetConfigType resets all changes to the "config_type" field.
func (m *ChangelogMutation) ResetConfigType() {
	m.config_type = nil
	delete(m.clearedFields, changelog.FieldConfigType)
}

// SetGitBranch sets the "git_branch" field.
func (m *ChangelogMutation) SetGitBranch(s string) {
	m.git_branch = &s
}

// GitBranch returns the value of the "git_branch" field in the mutation.
func (m *ChangelogMutation) GitBranch() (r string, exists bool) {
	v := m.git_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldGitBranch returns the old "git_branch" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitBranch: %w", err)
	}
	return oldValue.GitBranch, nil
}

// ResetGitBranch resets all changes to the "git_branch" field.
func (m *ChangelogMutation) ResetGitBranch() {
	m.git_branch = nil
}

// SetGitCommit sets the "git_commit" field.
func (m *ChangelogMutation) SetGitCommit(s string) {
	m.git_commit = &s
}

// GitCommit returns the value of the "git_commit" field in the mutation.
func (m *ChangelogMutation) GitCommit() (r string, exists bool) {
	v := m.git_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommit returns the old "git_commit" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommit: %w", err)
	}
	return oldValue.GitCommit, nil
}

// ResetGitCommit resets all changes to the "git_commit" field.
func (m *ChangelogMutation) ResetGitCommit() {
	m.git_commit = nil
}

// SetDockerImage sets the "docker_image" field.
func (m *ChangelogMutation) SetDockerImage(s []string) {
	m.docker_image = &s
	m.appenddocker_image = nil
}

// DockerImage returns the value of the "docker_image" field in the mutation.
func (m *ChangelogMutation) DockerImage() (r []string, exists bool) {
	v := m.docker_image
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerImage returns the old "docker_image" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldDockerImage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerImage: %w", err)
	}
	return oldValue.DockerImage, nil
}

// AppendDockerImage adds s to the "docker_image" field.
func (m *ChangelogMutation) AppendDockerImage(s []string) {
	m.appenddocker_image = append(m.appenddocker_image, s...)
}

// AppendedDockerImage returns the list of values that were appended to the "docker_image" field in this mutation.
func (m *ChangelogMutation) AppendedDockerImage() ([]string, bool) {
	if len(m.appenddocker_image) == 0 {
		return nil, false
	}
	return m.appenddocker_image, true
}

// ClearDockerImage clears the value of the "docker_image" field.
func (m *ChangelogMutation) ClearDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	m.clearedFields[changelog.FieldDockerImage] = struct{}{}
}

// DockerImageCleared returns if the "docker_image" field was cleared in this mutation.
func (m *ChangelogMutation) DockerImageCleared() bool {
	_, ok := m.clearedFields[changelog.FieldDockerImage]
	return ok
}

// ResetDockerImage resets all changes to the "docker_image" field.
func (m *ChangelogMutation) ResetDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	delete(m.clearedFields, changelog.FieldDockerImage)
}

// SetEnvValues sets the "env_values" field.
func (m *ChangelogMutation) SetEnvValues(tv []*types.KeyValue) {
	m.env_values = &tv
	m.appendenv_values = nil
}

// EnvValues returns the value of the "env_values" field in the mutation.
func (m *ChangelogMutation) EnvValues() (r []*types.KeyValue, exists bool) {
	v := m.env_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvValues returns the old "env_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldEnvValues(ctx context.Context) (v []*types.KeyValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvValues: %w", err)
	}
	return oldValue.EnvValues, nil
}

// AppendEnvValues adds tv to the "env_values" field.
func (m *ChangelogMutation) AppendEnvValues(tv []*types.KeyValue) {
	m.appendenv_values = append(m.appendenv_values, tv...)
}

// AppendedEnvValues returns the list of values that were appended to the "env_values" field in this mutation.
func (m *ChangelogMutation) AppendedEnvValues() ([]*types.KeyValue, bool) {
	if len(m.appendenv_values) == 0 {
		return nil, false
	}
	return m.appendenv_values, true
}

// ClearEnvValues clears the value of the "env_values" field.
func (m *ChangelogMutation) ClearEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	m.clearedFields[changelog.FieldEnvValues] = struct{}{}
}

// EnvValuesCleared returns if the "env_values" field was cleared in this mutation.
func (m *ChangelogMutation) EnvValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldEnvValues]
	return ok
}

// ResetEnvValues resets all changes to the "env_values" field.
func (m *ChangelogMutation) ResetEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	delete(m.clearedFields, changelog.FieldEnvValues)
}

// SetExtraValues sets the "extra_values" field.
func (m *ChangelogMutation) SetExtraValues(tv []*types.ExtraValue) {
	m.extra_values = &tv
	m.appendextra_values = nil
}

// ExtraValues returns the value of the "extra_values" field in the mutation.
func (m *ChangelogMutation) ExtraValues() (r []*types.ExtraValue, exists bool) {
	v := m.extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraValues returns the old "extra_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldExtraValues(ctx context.Context) (v []*types.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraValues: %w", err)
	}
	return oldValue.ExtraValues, nil
}

// AppendExtraValues adds tv to the "extra_values" field.
func (m *ChangelogMutation) AppendExtraValues(tv []*types.ExtraValue) {
	m.appendextra_values = append(m.appendextra_values, tv...)
}

// AppendedExtraValues returns the list of values that were appended to the "extra_values" field in this mutation.
func (m *ChangelogMutation) AppendedExtraValues() ([]*types.ExtraValue, bool) {
	if len(m.appendextra_values) == 0 {
		return nil, false
	}
	return m.appendextra_values, true
}

// ClearExtraValues clears the value of the "extra_values" field.
func (m *ChangelogMutation) ClearExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	m.clearedFields[changelog.FieldExtraValues] = struct{}{}
}

// ExtraValuesCleared returns if the "extra_values" field was cleared in this mutation.
func (m *ChangelogMutation) ExtraValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldExtraValues]
	return ok
}

// ResetExtraValues resets all changes to the "extra_values" field.
func (m *ChangelogMutation) ResetExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	delete(m.clearedFields, changelog.FieldExtraValues)
}

// SetFinalExtraValues sets the "final_extra_values" field.
func (m *ChangelogMutation) SetFinalExtraValues(s []string) {
	m.final_extra_values = &s
	m.appendfinal_extra_values = nil
}

// FinalExtraValues returns the value of the "final_extra_values" field in the mutation.
func (m *ChangelogMutation) FinalExtraValues() (r []string, exists bool) {
	v := m.final_extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalExtraValues returns the old "final_extra_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldFinalExtraValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalExtraValues: %w", err)
	}
	return oldValue.FinalExtraValues, nil
}

// AppendFinalExtraValues adds s to the "final_extra_values" field.
func (m *ChangelogMutation) AppendFinalExtraValues(s []string) {
	m.appendfinal_extra_values = append(m.appendfinal_extra_values, s...)
}

// AppendedFinalExtraValues returns the list of values that were appended to the "final_extra_values" field in this mutation.
func (m *ChangelogMutation) AppendedFinalExtraValues() ([]string, bool) {
	if len(m.appendfinal_extra_values) == 0 {
		return nil, false
	}
	return m.appendfinal_extra_values, true
}

// ClearFinalExtraValues clears the value of the "final_extra_values" field.
func (m *ChangelogMutation) ClearFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	m.clearedFields[changelog.FieldFinalExtraValues] = struct{}{}
}

// FinalExtraValuesCleared returns if the "final_extra_values" field was cleared in this mutation.
func (m *ChangelogMutation) FinalExtraValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldFinalExtraValues]
	return ok
}

// ResetFinalExtraValues resets all changes to the "final_extra_values" field.
func (m *ChangelogMutation) ResetFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	delete(m.clearedFields, changelog.FieldFinalExtraValues)
}

// SetGitCommitWebURL sets the "git_commit_web_url" field.
func (m *ChangelogMutation) SetGitCommitWebURL(s string) {
	m.git_commit_web_url = &s
}

// GitCommitWebURL returns the value of the "git_commit_web_url" field in the mutation.
func (m *ChangelogMutation) GitCommitWebURL() (r string, exists bool) {
	v := m.git_commit_web_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitWebURL returns the old "git_commit_web_url" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitWebURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitWebURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitWebURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitWebURL: %w", err)
	}
	return oldValue.GitCommitWebURL, nil
}

// ClearGitCommitWebURL clears the value of the "git_commit_web_url" field.
func (m *ChangelogMutation) ClearGitCommitWebURL() {
	m.git_commit_web_url = nil
	m.clearedFields[changelog.FieldGitCommitWebURL] = struct{}{}
}

// GitCommitWebURLCleared returns if the "git_commit_web_url" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitWebURLCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitWebURL]
	return ok
}

// ResetGitCommitWebURL resets all changes to the "git_commit_web_url" field.
func (m *ChangelogMutation) ResetGitCommitWebURL() {
	m.git_commit_web_url = nil
	delete(m.clearedFields, changelog.FieldGitCommitWebURL)
}

// SetGitCommitTitle sets the "git_commit_title" field.
func (m *ChangelogMutation) SetGitCommitTitle(s string) {
	m.git_commit_title = &s
}

// GitCommitTitle returns the value of the "git_commit_title" field in the mutation.
func (m *ChangelogMutation) GitCommitTitle() (r string, exists bool) {
	v := m.git_commit_title
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitTitle returns the old "git_commit_title" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitTitle: %w", err)
	}
	return oldValue.GitCommitTitle, nil
}

// ClearGitCommitTitle clears the value of the "git_commit_title" field.
func (m *ChangelogMutation) ClearGitCommitTitle() {
	m.git_commit_title = nil
	m.clearedFields[changelog.FieldGitCommitTitle] = struct{}{}
}

// GitCommitTitleCleared returns if the "git_commit_title" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitTitleCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitTitle]
	return ok
}

// ResetGitCommitTitle resets all changes to the "git_commit_title" field.
func (m *ChangelogMutation) ResetGitCommitTitle() {
	m.git_commit_title = nil
	delete(m.clearedFields, changelog.FieldGitCommitTitle)
}

// SetGitCommitAuthor sets the "git_commit_author" field.
func (m *ChangelogMutation) SetGitCommitAuthor(s string) {
	m.git_commit_author = &s
}

// GitCommitAuthor returns the value of the "git_commit_author" field in the mutation.
func (m *ChangelogMutation) GitCommitAuthor() (r string, exists bool) {
	v := m.git_commit_author
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitAuthor returns the old "git_commit_author" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitAuthor: %w", err)
	}
	return oldValue.GitCommitAuthor, nil
}

// ClearGitCommitAuthor clears the value of the "git_commit_author" field.
func (m *ChangelogMutation) ClearGitCommitAuthor() {
	m.git_commit_author = nil
	m.clearedFields[changelog.FieldGitCommitAuthor] = struct{}{}
}

// GitCommitAuthorCleared returns if the "git_commit_author" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitAuthorCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitAuthor]
	return ok
}

// ResetGitCommitAuthor resets all changes to the "git_commit_author" field.
func (m *ChangelogMutation) ResetGitCommitAuthor() {
	m.git_commit_author = nil
	delete(m.clearedFields, changelog.FieldGitCommitAuthor)
}

// SetGitCommitDate sets the "git_commit_date" field.
func (m *ChangelogMutation) SetGitCommitDate(t time.Time) {
	m.git_commit_date = &t
}

// GitCommitDate returns the value of the "git_commit_date" field in the mutation.
func (m *ChangelogMutation) GitCommitDate() (r time.Time, exists bool) {
	v := m.git_commit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitDate returns the old "git_commit_date" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitDate: %w", err)
	}
	return oldValue.GitCommitDate, nil
}

// ClearGitCommitDate clears the value of the "git_commit_date" field.
func (m *ChangelogMutation) ClearGitCommitDate() {
	m.git_commit_date = nil
	m.clearedFields[changelog.FieldGitCommitDate] = struct{}{}
}

// GitCommitDateCleared returns if the "git_commit_date" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitDateCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitDate]
	return ok
}

// ResetGitCommitDate resets all changes to the "git_commit_date" field.
func (m *ChangelogMutation) ResetGitCommitDate() {
	m.git_commit_date = nil
	delete(m.clearedFields, changelog.FieldGitCommitDate)
}

// SetConfigChanged sets the "config_changed" field.
func (m *ChangelogMutation) SetConfigChanged(b bool) {
	m.config_changed = &b
}

// ConfigChanged returns the value of the "config_changed" field in the mutation.
func (m *ChangelogMutation) ConfigChanged() (r bool, exists bool) {
	v := m.config_changed
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigChanged returns the old "config_changed" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldConfigChanged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigChanged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigChanged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigChanged: %w", err)
	}
	return oldValue.ConfigChanged, nil
}

// ResetConfigChanged resets all changes to the "config_changed" field.
func (m *ChangelogMutation) ResetConfigChanged() {
	m.config_changed = nil
}

// SetProjectID sets the "project_id" field.
func (m *ChangelogMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ChangelogMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *ChangelogMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[changelog.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *ChangelogMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[changelog.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ChangelogMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, changelog.FieldProjectID)
}

// SetGitProjectID sets the "git_project_id" field.
func (m *ChangelogMutation) SetGitProjectID(i int) {
	m.git_project = &i
}

// GitProjectID returns the value of the "git_project_id" field in the mutation.
func (m *ChangelogMutation) GitProjectID() (r int, exists bool) {
	v := m.git_project
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectID returns the old "git_project_id" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectID: %w", err)
	}
	return oldValue.GitProjectID, nil
}

// ClearGitProjectID clears the value of the "git_project_id" field.
func (m *ChangelogMutation) ClearGitProjectID() {
	m.git_project = nil
	m.clearedFields[changelog.FieldGitProjectID] = struct{}{}
}

// GitProjectIDCleared returns if the "git_project_id" field was cleared in this mutation.
func (m *ChangelogMutation) GitProjectIDCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitProjectID]
	return ok
}

// ResetGitProjectID resets all changes to the "git_project_id" field.
func (m *ChangelogMutation) ResetGitProjectID() {
	m.git_project = nil
	delete(m.clearedFields, changelog.FieldGitProjectID)
}

// ClearGitProject clears the "git_project" edge to the GitProject entity.
func (m *ChangelogMutation) ClearGitProject() {
	m.clearedgit_project = true
	m.clearedFields[changelog.FieldGitProjectID] = struct{}{}
}

// GitProjectCleared reports if the "git_project" edge to the GitProject entity was cleared.
func (m *ChangelogMutation) GitProjectCleared() bool {
	return m.GitProjectIDCleared() || m.clearedgit_project
}

// GitProjectIDs returns the "git_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GitProjectID instead. It exists only for internal usage by the builders.
func (m *ChangelogMutation) GitProjectIDs() (ids []int) {
	if id := m.git_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGitProject resets all changes to the "git_project" edge.
func (m *ChangelogMutation) ResetGitProject() {
	m.git_project = nil
	m.clearedgit_project = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ChangelogMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[changelog.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ChangelogMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ChangelogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ChangelogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ChangelogMutation builder.
func (m *ChangelogMutation) Where(ps ...predicate.Changelog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangelogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangelogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Changelog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangelogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangelogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Changelog).
func (m *ChangelogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangelogMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, changelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, changelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, changelog.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, changelog.FieldVersion)
	}
	if m.username != nil {
		fields = append(fields, changelog.FieldUsername)
	}
	if m.manifest != nil {
		fields = append(fields, changelog.FieldManifest)
	}
	if m._config != nil {
		fields = append(fields, changelog.FieldConfig)
	}
	if m.config_type != nil {
		fields = append(fields, changelog.FieldConfigType)
	}
	if m.git_branch != nil {
		fields = append(fields, changelog.FieldGitBranch)
	}
	if m.git_commit != nil {
		fields = append(fields, changelog.FieldGitCommit)
	}
	if m.docker_image != nil {
		fields = append(fields, changelog.FieldDockerImage)
	}
	if m.env_values != nil {
		fields = append(fields, changelog.FieldEnvValues)
	}
	if m.extra_values != nil {
		fields = append(fields, changelog.FieldExtraValues)
	}
	if m.final_extra_values != nil {
		fields = append(fields, changelog.FieldFinalExtraValues)
	}
	if m.git_commit_web_url != nil {
		fields = append(fields, changelog.FieldGitCommitWebURL)
	}
	if m.git_commit_title != nil {
		fields = append(fields, changelog.FieldGitCommitTitle)
	}
	if m.git_commit_author != nil {
		fields = append(fields, changelog.FieldGitCommitAuthor)
	}
	if m.git_commit_date != nil {
		fields = append(fields, changelog.FieldGitCommitDate)
	}
	if m.config_changed != nil {
		fields = append(fields, changelog.FieldConfigChanged)
	}
	if m.project != nil {
		fields = append(fields, changelog.FieldProjectID)
	}
	if m.git_project != nil {
		fields = append(fields, changelog.FieldGitProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangelogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case changelog.FieldCreatedAt:
		return m.CreatedAt()
	case changelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case changelog.FieldDeletedAt:
		return m.DeletedAt()
	case changelog.FieldVersion:
		return m.Version()
	case changelog.FieldUsername:
		return m.Username()
	case changelog.FieldManifest:
		return m.Manifest()
	case changelog.FieldConfig:
		return m.Config()
	case changelog.FieldConfigType:
		return m.ConfigType()
	case changelog.FieldGitBranch:
		return m.GitBranch()
	case changelog.FieldGitCommit:
		return m.GitCommit()
	case changelog.FieldDockerImage:
		return m.DockerImage()
	case changelog.FieldEnvValues:
		return m.EnvValues()
	case changelog.FieldExtraValues:
		return m.ExtraValues()
	case changelog.FieldFinalExtraValues:
		return m.FinalExtraValues()
	case changelog.FieldGitCommitWebURL:
		return m.GitCommitWebURL()
	case changelog.FieldGitCommitTitle:
		return m.GitCommitTitle()
	case changelog.FieldGitCommitAuthor:
		return m.GitCommitAuthor()
	case changelog.FieldGitCommitDate:
		return m.GitCommitDate()
	case changelog.FieldConfigChanged:
		return m.ConfigChanged()
	case changelog.FieldProjectID:
		return m.ProjectID()
	case changelog.FieldGitProjectID:
		return m.GitProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangelogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case changelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case changelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case changelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case changelog.FieldVersion:
		return m.OldVersion(ctx)
	case changelog.FieldUsername:
		return m.OldUsername(ctx)
	case changelog.FieldManifest:
		return m.OldManifest(ctx)
	case changelog.FieldConfig:
		return m.OldConfig(ctx)
	case changelog.FieldConfigType:
		return m.OldConfigType(ctx)
	case changelog.FieldGitBranch:
		return m.OldGitBranch(ctx)
	case changelog.FieldGitCommit:
		return m.OldGitCommit(ctx)
	case changelog.FieldDockerImage:
		return m.OldDockerImage(ctx)
	case changelog.FieldEnvValues:
		return m.OldEnvValues(ctx)
	case changelog.FieldExtraValues:
		return m.OldExtraValues(ctx)
	case changelog.FieldFinalExtraValues:
		return m.OldFinalExtraValues(ctx)
	case changelog.FieldGitCommitWebURL:
		return m.OldGitCommitWebURL(ctx)
	case changelog.FieldGitCommitTitle:
		return m.OldGitCommitTitle(ctx)
	case changelog.FieldGitCommitAuthor:
		return m.OldGitCommitAuthor(ctx)
	case changelog.FieldGitCommitDate:
		return m.OldGitCommitDate(ctx)
	case changelog.FieldConfigChanged:
		return m.OldConfigChanged(ctx)
	case changelog.FieldProjectID:
		return m.OldProjectID(ctx)
	case changelog.FieldGitProjectID:
		return m.OldGitProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Changelog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangelogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case changelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case changelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case changelog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case changelog.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case changelog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case changelog.FieldManifest:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifest(v)
		return nil
	case changelog.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case changelog.FieldConfigType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigType(v)
		return nil
	case changelog.FieldGitBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitBranch(v)
		return nil
	case changelog.FieldGitCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommit(v)
		return nil
	case changelog.FieldDockerImage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerImage(v)
		return nil
	case changelog.FieldEnvValues:
		v, ok := value.([]*types.KeyValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvValues(v)
		return nil
	case changelog.FieldExtraValues:
		v, ok := value.([]*types.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraValues(v)
		return nil
	case changelog.FieldFinalExtraValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalExtraValues(v)
		return nil
	case changelog.FieldGitCommitWebURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitWebURL(v)
		return nil
	case changelog.FieldGitCommitTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitTitle(v)
		return nil
	case changelog.FieldGitCommitAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitAuthor(v)
		return nil
	case changelog.FieldGitCommitDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitDate(v)
		return nil
	case changelog.FieldConfigChanged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigChanged(v)
		return nil
	case changelog.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case changelog.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Changelog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangelogMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, changelog.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangelogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case changelog.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangelogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case changelog.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Changelog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangelogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(changelog.FieldDeletedAt) {
		fields = append(fields, changelog.FieldDeletedAt)
	}
	if m.FieldCleared(changelog.FieldManifest) {
		fields = append(fields, changelog.FieldManifest)
	}
	if m.FieldCleared(changelog.FieldConfig) {
		fields = append(fields, changelog.FieldConfig)
	}
	if m.FieldCleared(changelog.FieldConfigType) {
		fields = append(fields, changelog.FieldConfigType)
	}
	if m.FieldCleared(changelog.FieldDockerImage) {
		fields = append(fields, changelog.FieldDockerImage)
	}
	if m.FieldCleared(changelog.FieldEnvValues) {
		fields = append(fields, changelog.FieldEnvValues)
	}
	if m.FieldCleared(changelog.FieldExtraValues) {
		fields = append(fields, changelog.FieldExtraValues)
	}
	if m.FieldCleared(changelog.FieldFinalExtraValues) {
		fields = append(fields, changelog.FieldFinalExtraValues)
	}
	if m.FieldCleared(changelog.FieldGitCommitWebURL) {
		fields = append(fields, changelog.FieldGitCommitWebURL)
	}
	if m.FieldCleared(changelog.FieldGitCommitTitle) {
		fields = append(fields, changelog.FieldGitCommitTitle)
	}
	if m.FieldCleared(changelog.FieldGitCommitAuthor) {
		fields = append(fields, changelog.FieldGitCommitAuthor)
	}
	if m.FieldCleared(changelog.FieldGitCommitDate) {
		fields = append(fields, changelog.FieldGitCommitDate)
	}
	if m.FieldCleared(changelog.FieldProjectID) {
		fields = append(fields, changelog.FieldProjectID)
	}
	if m.FieldCleared(changelog.FieldGitProjectID) {
		fields = append(fields, changelog.FieldGitProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangelogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangelogMutation) ClearField(name string) error {
	switch name {
	case changelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case changelog.FieldManifest:
		m.ClearManifest()
		return nil
	case changelog.FieldConfig:
		m.ClearConfig()
		return nil
	case changelog.FieldConfigType:
		m.ClearConfigType()
		return nil
	case changelog.FieldDockerImage:
		m.ClearDockerImage()
		return nil
	case changelog.FieldEnvValues:
		m.ClearEnvValues()
		return nil
	case changelog.FieldExtraValues:
		m.ClearExtraValues()
		return nil
	case changelog.FieldFinalExtraValues:
		m.ClearFinalExtraValues()
		return nil
	case changelog.FieldGitCommitWebURL:
		m.ClearGitCommitWebURL()
		return nil
	case changelog.FieldGitCommitTitle:
		m.ClearGitCommitTitle()
		return nil
	case changelog.FieldGitCommitAuthor:
		m.ClearGitCommitAuthor()
		return nil
	case changelog.FieldGitCommitDate:
		m.ClearGitCommitDate()
		return nil
	case changelog.FieldProjectID:
		m.ClearProjectID()
		return nil
	case changelog.FieldGitProjectID:
		m.ClearGitProjectID()
		return nil
	}
	return fmt.Errorf("unknown Changelog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangelogMutation) ResetField(name string) error {
	switch name {
	case changelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case changelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case changelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case changelog.FieldVersion:
		m.ResetVersion()
		return nil
	case changelog.FieldUsername:
		m.ResetUsername()
		return nil
	case changelog.FieldManifest:
		m.ResetManifest()
		return nil
	case changelog.FieldConfig:
		m.ResetConfig()
		return nil
	case changelog.FieldConfigType:
		m.ResetConfigType()
		return nil
	case changelog.FieldGitBranch:
		m.ResetGitBranch()
		return nil
	case changelog.FieldGitCommit:
		m.ResetGitCommit()
		return nil
	case changelog.FieldDockerImage:
		m.ResetDockerImage()
		return nil
	case changelog.FieldEnvValues:
		m.ResetEnvValues()
		return nil
	case changelog.FieldExtraValues:
		m.ResetExtraValues()
		return nil
	case changelog.FieldFinalExtraValues:
		m.ResetFinalExtraValues()
		return nil
	case changelog.FieldGitCommitWebURL:
		m.ResetGitCommitWebURL()
		return nil
	case changelog.FieldGitCommitTitle:
		m.ResetGitCommitTitle()
		return nil
	case changelog.FieldGitCommitAuthor:
		m.ResetGitCommitAuthor()
		return nil
	case changelog.FieldGitCommitDate:
		m.ResetGitCommitDate()
		return nil
	case changelog.FieldConfigChanged:
		m.ResetConfigChanged()
		return nil
	case changelog.FieldProjectID:
		m.ResetProjectID()
		return nil
	case changelog.FieldGitProjectID:
		m.ResetGitProjectID()
		return nil
	}
	return fmt.Errorf("unknown Changelog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangelogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.git_project != nil {
		edges = append(edges, changelog.EdgeGitProject)
	}
	if m.project != nil {
		edges = append(edges, changelog.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangelogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case changelog.EdgeGitProject:
		if id := m.git_project; id != nil {
			return []ent.Value{*id}
		}
	case changelog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangelogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangelogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangelogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgit_project {
		edges = append(edges, changelog.EdgeGitProject)
	}
	if m.clearedproject {
		edges = append(edges, changelog.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangelogMutation) EdgeCleared(name string) bool {
	switch name {
	case changelog.EdgeGitProject:
		return m.clearedgit_project
	case changelog.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangelogMutation) ClearEdge(name string) error {
	switch name {
	case changelog.EdgeGitProject:
		m.ClearGitProject()
		return nil
	case changelog.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Changelog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangelogMutation) ResetEdge(name string) error {
	switch name {
	case changelog.EdgeGitProject:
		m.ResetGitProject()
		return nil
	case changelog.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Changelog edge %s", name)
}

// DBCacheMutation represents an operation that mutates the DBCache nodes in the graph.
type DBCacheMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DBCache, error)
	predicates    []predicate.DBCache
}

var _ ent.Mutation = (*DBCacheMutation)(nil)

// dbcacheOption allows management of the mutation configuration using functional options.
type dbcacheOption func(*DBCacheMutation)

// newDBCacheMutation creates new mutation for the DBCache entity.
func newDBCacheMutation(c config, op Op, opts ...dbcacheOption) *DBCacheMutation {
	m := &DBCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeDBCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDBCacheID sets the ID field of the mutation.
func withDBCacheID(id int) dbcacheOption {
	return func(m *DBCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *DBCache
		)
		m.oldValue = func(ctx context.Context) (*DBCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DBCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDBCache sets the old DBCache of the mutation.
func withDBCache(node *DBCache) dbcacheOption {
	return func(m *DBCacheMutation) {
		m.oldValue = func(context.Context) (*DBCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DBCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DBCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DBCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DBCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DBCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *DBCacheMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DBCacheMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DBCacheMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DBCacheMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DBCacheMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *DBCacheMutation) ClearValue() {
	m.value = nil
	m.clearedFields[dbcache.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *DBCacheMutation) ValueCleared() bool {
	_, ok := m.clearedFields[dbcache.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *DBCacheMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, dbcache.FieldValue)
}

// SetExpiredAt sets the "expired_at" field.
func (m *DBCacheMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *DBCacheMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *DBCacheMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[dbcache.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *DBCacheMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[dbcache.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *DBCacheMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, dbcache.FieldExpiredAt)
}

// Where appends a list predicates to the DBCacheMutation builder.
func (m *DBCacheMutation) Where(ps ...predicate.DBCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DBCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DBCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DBCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DBCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DBCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DBCache).
func (m *DBCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DBCacheMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, dbcache.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dbcache.FieldValue)
	}
	if m.expired_at != nil {
		fields = append(fields, dbcache.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DBCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbcache.FieldKey:
		return m.Key()
	case dbcache.FieldValue:
		return m.Value()
	case dbcache.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DBCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbcache.FieldKey:
		return m.OldKey(ctx)
	case dbcache.FieldValue:
		return m.OldValue(ctx)
	case dbcache.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown DBCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DBCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbcache.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dbcache.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dbcache.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown DBCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DBCacheMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DBCacheMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DBCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DBCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DBCacheMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbcache.FieldValue) {
		fields = append(fields, dbcache.FieldValue)
	}
	if m.FieldCleared(dbcache.FieldExpiredAt) {
		fields = append(fields, dbcache.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DBCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DBCacheMutation) ClearField(name string) error {
	switch name {
	case dbcache.FieldValue:
		m.ClearValue()
		return nil
	case dbcache.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown DBCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DBCacheMutation) ResetField(name string) error {
	switch name {
	case dbcache.FieldKey:
		m.ResetKey()
		return nil
	case dbcache.FieldValue:
		m.ResetValue()
		return nil
	case dbcache.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown DBCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DBCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DBCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DBCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DBCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DBCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DBCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DBCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DBCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DBCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DBCache edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	action        *types.EventActionType
	addaction     *types.EventActionType
	username      *string
	message       *string
	old           *string
	new           *string
	duration      *string
	clearedFields map[string]struct{}
	file          *int
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// SetAction sets the "action" field.
func (m *EventMutation) SetAction(tat types.EventActionType) {
	m.action = &tat
	m.addaction = nil
}

// Action returns the value of the "action" field in the mutation.
func (m *EventMutation) Action() (r types.EventActionType, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAction(ctx context.Context) (v types.EventActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// AddAction adds tat to the "action" field.
func (m *EventMutation) AddAction(tat types.EventActionType) {
	if m.addaction != nil {
		*m.addaction += tat
	} else {
		m.addaction = &tat
	}
}

// AddedAction returns the value that was added to the "action" field in this mutation.
func (m *EventMutation) AddedAction() (r types.EventActionType, exists bool) {
	v := m.addaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction resets all changes to the "action" field.
func (m *EventMutation) ResetAction() {
	m.action = nil
	m.addaction = nil
}

// SetUsername sets the "username" field.
func (m *EventMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *EventMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *EventMutation) ResetUsername() {
	m.username = nil
}

// SetMessage sets the "message" field.
func (m *EventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *EventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *EventMutation) ResetMessage() {
	m.message = nil
}

// SetOld sets the "old" field.
func (m *EventMutation) SetOld(s string) {
	m.old = &s
}

// Old returns the value of the "old" field in the mutation.
func (m *EventMutation) Old() (r string, exists bool) {
	v := m.old
	if v == nil {
		return
	}
	return *v, true
}

// OldOld returns the old "old" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldOld(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOld: %w", err)
	}
	return oldValue.Old, nil
}

// ResetOld resets all changes to the "old" field.
func (m *EventMutation) ResetOld() {
	m.old = nil
}

// SetNew sets the "new" field.
func (m *EventMutation) SetNew(s string) {
	m.new = &s
}

// New returns the value of the "new" field in the mutation.
func (m *EventMutation) New() (r string, exists bool) {
	v := m.new
	if v == nil {
		return
	}
	return *v, true
}

// OldNew returns the old "new" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldNew(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNew: %w", err)
	}
	return oldValue.New, nil
}

// ResetNew resets all changes to the "new" field.
func (m *EventMutation) ResetNew() {
	m.new = nil
}

// SetDuration sets the "duration" field.
func (m *EventMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *EventMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ResetDuration resets all changes to the "duration" field.
func (m *EventMutation) ResetDuration() {
	m.duration = nil
}

// SetFileID sets the "file_id" field.
func (m *EventMutation) SetFileID(i int) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *EventMutation) FileID() (r int, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFileID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *EventMutation) ClearFileID() {
	m.file = nil
	m.clearedFields[event.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *EventMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[event.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *EventMutation) ResetFileID() {
	m.file = nil
	delete(m.clearedFields, event.FieldFileID)
}

// ClearFile clears the "file" edge to the File entity.
func (m *EventMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[event.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *EventMutation) FileCleared() bool {
	return m.FileIDCleared() || m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *EventMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *EventMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.action != nil {
		fields = append(fields, event.FieldAction)
	}
	if m.username != nil {
		fields = append(fields, event.FieldUsername)
	}
	if m.message != nil {
		fields = append(fields, event.FieldMessage)
	}
	if m.old != nil {
		fields = append(fields, event.FieldOld)
	}
	if m.new != nil {
		fields = append(fields, event.FieldNew)
	}
	if m.duration != nil {
		fields = append(fields, event.FieldDuration)
	}
	if m.file != nil {
		fields = append(fields, event.FieldFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldAction:
		return m.Action()
	case event.FieldUsername:
		return m.Username()
	case event.FieldMessage:
		return m.Message()
	case event.FieldOld:
		return m.Old()
	case event.FieldNew:
		return m.New()
	case event.FieldDuration:
		return m.Duration()
	case event.FieldFileID:
		return m.FileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldAction:
		return m.OldAction(ctx)
	case event.FieldUsername:
		return m.OldUsername(ctx)
	case event.FieldMessage:
		return m.OldMessage(ctx)
	case event.FieldOld:
		return m.OldOld(ctx)
	case event.FieldNew:
		return m.OldNew(ctx)
	case event.FieldDuration:
		return m.OldDuration(ctx)
	case event.FieldFileID:
		return m.OldFileID(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldAction:
		v, ok := value.(types.EventActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case event.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case event.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case event.FieldOld:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOld(v)
		return nil
	case event.FieldNew:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNew(v)
		return nil
	case event.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case event.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addaction != nil {
		fields = append(fields, event.FieldAction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldAction:
		return m.AddedAction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldAction:
		v, ok := value.(types.EventActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.FieldCleared(event.FieldFileID) {
		fields = append(fields, event.FieldFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case event.FieldFileID:
		m.ClearFileID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldAction:
		m.ResetAction()
		return nil
	case event.FieldUsername:
		m.ResetUsername()
		return nil
	case event.FieldMessage:
		m.ResetMessage()
		return nil
	case event.FieldOld:
		m.ResetOld()
		return nil
	case event.FieldNew:
		m.ResetNew()
		return nil
	case event.FieldDuration:
		m.ResetDuration()
		return nil
	case event.FieldFileID:
		m.ResetFileID()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	upload_type    *schematype.UploadType
	_path          *string
	size           *uint64
	addsize        *int64
	username       *string
	namespace      *string
	pod            *string
	container      *string
	container_path *string
	clearedFields  map[string]struct{}
	events         map[int]struct{}
	removedevents  map[int]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetUploadType sets the "upload_type" field.
func (m *FileMutation) SetUploadType(st schematype.UploadType) {
	m.upload_type = &st
}

// UploadType returns the value of the "upload_type" field in the mutation.
func (m *FileMutation) UploadType() (r schematype.UploadType, exists bool) {
	v := m.upload_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadType returns the old "upload_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUploadType(ctx context.Context) (v schematype.UploadType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadType: %w", err)
	}
	return oldValue.UploadType, nil
}

// ResetUploadType resets all changes to the "upload_type" field.
func (m *FileMutation) ResetUploadType() {
	m.upload_type = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetUsername sets the "username" field.
func (m *FileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *FileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *FileMutation) ResetUsername() {
	m.username = nil
}

// SetNamespace sets the "namespace" field.
func (m *FileMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FileMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FileMutation) ResetNamespace() {
	m.namespace = nil
}

// SetPod sets the "pod" field.
func (m *FileMutation) SetPod(s string) {
	m.pod = &s
}

// Pod returns the value of the "pod" field in the mutation.
func (m *FileMutation) Pod() (r string, exists bool) {
	v := m.pod
	if v == nil {
		return
	}
	return *v, true
}

// OldPod returns the old "pod" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPod: %w", err)
	}
	return oldValue.Pod, nil
}

// ResetPod resets all changes to the "pod" field.
func (m *FileMutation) ResetPod() {
	m.pod = nil
}

// SetContainer sets the "container" field.
func (m *FileMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *FileMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ResetContainer resets all changes to the "container" field.
func (m *FileMutation) ResetContainer() {
	m.container = nil
}

// SetContainerPath sets the "container_path" field.
func (m *FileMutation) SetContainerPath(s string) {
	m.container_path = &s
}

// ContainerPath returns the value of the "container_path" field in the mutation.
func (m *FileMutation) ContainerPath() (r string, exists bool) {
	v := m.container_path
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerPath returns the old "container_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContainerPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerPath: %w", err)
	}
	return oldValue.ContainerPath, nil
}

// ResetContainerPath resets all changes to the "container_path" field.
func (m *FileMutation) ResetContainerPath() {
	m.container_path = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *FileMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *FileMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *FileMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *FileMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *FileMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *FileMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *FileMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.upload_type != nil {
		fields = append(fields, file.FieldUploadType)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.username != nil {
		fields = append(fields, file.FieldUsername)
	}
	if m.namespace != nil {
		fields = append(fields, file.FieldNamespace)
	}
	if m.pod != nil {
		fields = append(fields, file.FieldPod)
	}
	if m.container != nil {
		fields = append(fields, file.FieldContainer)
	}
	if m.container_path != nil {
		fields = append(fields, file.FieldContainerPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldUploadType:
		return m.UploadType()
	case file.FieldPath:
		return m.Path()
	case file.FieldSize:
		return m.Size()
	case file.FieldUsername:
		return m.Username()
	case file.FieldNamespace:
		return m.Namespace()
	case file.FieldPod:
		return m.Pod()
	case file.FieldContainer:
		return m.Container()
	case file.FieldContainerPath:
		return m.ContainerPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldUploadType:
		return m.OldUploadType(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldUsername:
		return m.OldUsername(ctx)
	case file.FieldNamespace:
		return m.OldNamespace(ctx)
	case file.FieldPod:
		return m.OldPod(ctx)
	case file.FieldContainer:
		return m.OldContainer(ctx)
	case file.FieldContainerPath:
		return m.OldContainerPath(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldUploadType:
		v, ok := value.(schematype.UploadType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadType(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case file.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case file.FieldPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPod(v)
		return nil
	case file.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case file.FieldContainerPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerPath(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldUploadType:
		m.ResetUploadType()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldUsername:
		m.ResetUsername()
		return nil
	case file.FieldNamespace:
		m.ResetNamespace()
		return nil
	case file.FieldPod:
		m.ResetPod()
		return nil
	case file.FieldContainer:
		m.ResetContainer()
		return nil
	case file.FieldContainerPath:
		m.ResetContainerPath()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// GitProjectMutation represents an operation that mutates the GitProject nodes in the graph.
type GitProjectMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	default_branch    *string
	git_project_id    *int
	addgit_project_id *int
	enabled           *bool
	global_enabled    *bool
	global_config     **mars.Config
	clearedFields     map[string]struct{}
	changelogs        map[int]struct{}
	removedchangelogs map[int]struct{}
	clearedchangelogs bool
	done              bool
	oldValue          func(context.Context) (*GitProject, error)
	predicates        []predicate.GitProject
}

var _ ent.Mutation = (*GitProjectMutation)(nil)

// gitprojectOption allows management of the mutation configuration using functional options.
type gitprojectOption func(*GitProjectMutation)

// newGitProjectMutation creates new mutation for the GitProject entity.
func newGitProjectMutation(c config, op Op, opts ...gitprojectOption) *GitProjectMutation {
	m := &GitProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeGitProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitProjectID sets the ID field of the mutation.
func withGitProjectID(id int) gitprojectOption {
	return func(m *GitProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *GitProject
		)
		m.oldValue = func(ctx context.Context) (*GitProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitProject sets the old GitProject of the mutation.
func withGitProject(node *GitProject) gitprojectOption {
	return func(m *GitProjectMutation) {
		m.oldValue = func(context.Context) (*GitProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GitProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GitProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GitProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GitProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GitProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GitProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GitProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GitProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GitProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GitProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GitProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[gitproject.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GitProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[gitproject.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GitProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, gitproject.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GitProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GitProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GitProjectMutation) ResetName() {
	m.name = nil
}

// SetDefaultBranch sets the "default_branch" field.
func (m *GitProjectMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *GitProjectMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldDefaultBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *GitProjectMutation) ResetDefaultBranch() {
	m.default_branch = nil
}

// SetGitProjectID sets the "git_project_id" field.
func (m *GitProjectMutation) SetGitProjectID(i int) {
	m.git_project_id = &i
	m.addgit_project_id = nil
}

// GitProjectID returns the value of the "git_project_id" field in the mutation.
func (m *GitProjectMutation) GitProjectID() (r int, exists bool) {
	v := m.git_project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectID returns the old "git_project_id" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldGitProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectID: %w", err)
	}
	return oldValue.GitProjectID, nil
}

// AddGitProjectID adds i to the "git_project_id" field.
func (m *GitProjectMutation) AddGitProjectID(i int) {
	if m.addgit_project_id != nil {
		*m.addgit_project_id += i
	} else {
		m.addgit_project_id = &i
	}
}

// AddedGitProjectID returns the value that was added to the "git_project_id" field in this mutation.
func (m *GitProjectMutation) AddedGitProjectID() (r int, exists bool) {
	v := m.addgit_project_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGitProjectID resets all changes to the "git_project_id" field.
func (m *GitProjectMutation) ResetGitProjectID() {
	m.git_project_id = nil
	m.addgit_project_id = nil
}

// SetEnabled sets the "enabled" field.
func (m *GitProjectMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *GitProjectMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *GitProjectMutation) ResetEnabled() {
	m.enabled = nil
}

// SetGlobalEnabled sets the "global_enabled" field.
func (m *GitProjectMutation) SetGlobalEnabled(b bool) {
	m.global_enabled = &b
}

// GlobalEnabled returns the value of the "global_enabled" field in the mutation.
func (m *GitProjectMutation) GlobalEnabled() (r bool, exists bool) {
	v := m.global_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalEnabled returns the old "global_enabled" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldGlobalEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalEnabled: %w", err)
	}
	return oldValue.GlobalEnabled, nil
}

// ResetGlobalEnabled resets all changes to the "global_enabled" field.
func (m *GitProjectMutation) ResetGlobalEnabled() {
	m.global_enabled = nil
}

// SetGlobalConfig sets the "global_config" field.
func (m *GitProjectMutation) SetGlobalConfig(value *mars.Config) {
	m.global_config = &value
}

// GlobalConfig returns the value of the "global_config" field in the mutation.
func (m *GitProjectMutation) GlobalConfig() (r *mars.Config, exists bool) {
	v := m.global_config
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalConfig returns the old "global_config" field's value of the GitProject entity.
// If the GitProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitProjectMutation) OldGlobalConfig(ctx context.Context) (v *mars.Config, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalConfig: %w", err)
	}
	return oldValue.GlobalConfig, nil
}

// ClearGlobalConfig clears the value of the "global_config" field.
func (m *GitProjectMutation) ClearGlobalConfig() {
	m.global_config = nil
	m.clearedFields[gitproject.FieldGlobalConfig] = struct{}{}
}

// GlobalConfigCleared returns if the "global_config" field was cleared in this mutation.
func (m *GitProjectMutation) GlobalConfigCleared() bool {
	_, ok := m.clearedFields[gitproject.FieldGlobalConfig]
	return ok
}

// ResetGlobalConfig resets all changes to the "global_config" field.
func (m *GitProjectMutation) ResetGlobalConfig() {
	m.global_config = nil
	delete(m.clearedFields, gitproject.FieldGlobalConfig)
}

// AddChangelogIDs adds the "changelogs" edge to the Changelog entity by ids.
func (m *GitProjectMutation) AddChangelogIDs(ids ...int) {
	if m.changelogs == nil {
		m.changelogs = make(map[int]struct{})
	}
	for i := range ids {
		m.changelogs[ids[i]] = struct{}{}
	}
}

// ClearChangelogs clears the "changelogs" edge to the Changelog entity.
func (m *GitProjectMutation) ClearChangelogs() {
	m.clearedchangelogs = true
}

// ChangelogsCleared reports if the "changelogs" edge to the Changelog entity was cleared.
func (m *GitProjectMutation) ChangelogsCleared() bool {
	return m.clearedchangelogs
}

// RemoveChangelogIDs removes the "changelogs" edge to the Changelog entity by IDs.
func (m *GitProjectMutation) RemoveChangelogIDs(ids ...int) {
	if m.removedchangelogs == nil {
		m.removedchangelogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.changelogs, ids[i])
		m.removedchangelogs[ids[i]] = struct{}{}
	}
}

// RemovedChangelogs returns the removed IDs of the "changelogs" edge to the Changelog entity.
func (m *GitProjectMutation) RemovedChangelogsIDs() (ids []int) {
	for id := range m.removedchangelogs {
		ids = append(ids, id)
	}
	return
}

// ChangelogsIDs returns the "changelogs" edge IDs in the mutation.
func (m *GitProjectMutation) ChangelogsIDs() (ids []int) {
	for id := range m.changelogs {
		ids = append(ids, id)
	}
	return
}

// ResetChangelogs resets all changes to the "changelogs" edge.
func (m *GitProjectMutation) ResetChangelogs() {
	m.changelogs = nil
	m.clearedchangelogs = false
	m.removedchangelogs = nil
}

// Where appends a list predicates to the GitProjectMutation builder.
func (m *GitProjectMutation) Where(ps ...predicate.GitProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GitProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GitProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GitProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GitProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GitProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GitProject).
func (m *GitProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitProjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, gitproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gitproject.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, gitproject.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, gitproject.FieldName)
	}
	if m.default_branch != nil {
		fields = append(fields, gitproject.FieldDefaultBranch)
	}
	if m.git_project_id != nil {
		fields = append(fields, gitproject.FieldGitProjectID)
	}
	if m.enabled != nil {
		fields = append(fields, gitproject.FieldEnabled)
	}
	if m.global_enabled != nil {
		fields = append(fields, gitproject.FieldGlobalEnabled)
	}
	if m.global_config != nil {
		fields = append(fields, gitproject.FieldGlobalConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gitproject.FieldCreatedAt:
		return m.CreatedAt()
	case gitproject.FieldUpdatedAt:
		return m.UpdatedAt()
	case gitproject.FieldDeletedAt:
		return m.DeletedAt()
	case gitproject.FieldName:
		return m.Name()
	case gitproject.FieldDefaultBranch:
		return m.DefaultBranch()
	case gitproject.FieldGitProjectID:
		return m.GitProjectID()
	case gitproject.FieldEnabled:
		return m.Enabled()
	case gitproject.FieldGlobalEnabled:
		return m.GlobalEnabled()
	case gitproject.FieldGlobalConfig:
		return m.GlobalConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gitproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gitproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gitproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case gitproject.FieldName:
		return m.OldName(ctx)
	case gitproject.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	case gitproject.FieldGitProjectID:
		return m.OldGitProjectID(ctx)
	case gitproject.FieldEnabled:
		return m.OldEnabled(ctx)
	case gitproject.FieldGlobalEnabled:
		return m.OldGlobalEnabled(ctx)
	case gitproject.FieldGlobalConfig:
		return m.OldGlobalConfig(ctx)
	}
	return nil, fmt.Errorf("unknown GitProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gitproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gitproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gitproject.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case gitproject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gitproject.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	case gitproject.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectID(v)
		return nil
	case gitproject.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case gitproject.FieldGlobalEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalEnabled(v)
		return nil
	case gitproject.FieldGlobalConfig:
		v, ok := value.(*mars.Config)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalConfig(v)
		return nil
	}
	return fmt.Errorf("unknown GitProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitProjectMutation) AddedFields() []string {
	var fields []string
	if m.addgit_project_id != nil {
		fields = append(fields, gitproject.FieldGitProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gitproject.FieldGitProjectID:
		return m.AddedGitProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gitproject.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGitProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown GitProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gitproject.FieldDeletedAt) {
		fields = append(fields, gitproject.FieldDeletedAt)
	}
	if m.FieldCleared(gitproject.FieldGlobalConfig) {
		fields = append(fields, gitproject.FieldGlobalConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitProjectMutation) ClearField(name string) error {
	switch name {
	case gitproject.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case gitproject.FieldGlobalConfig:
		m.ClearGlobalConfig()
		return nil
	}
	return fmt.Errorf("unknown GitProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitProjectMutation) ResetField(name string) error {
	switch name {
	case gitproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gitproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gitproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case gitproject.FieldName:
		m.ResetName()
		return nil
	case gitproject.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	case gitproject.FieldGitProjectID:
		m.ResetGitProjectID()
		return nil
	case gitproject.FieldEnabled:
		m.ResetEnabled()
		return nil
	case gitproject.FieldGlobalEnabled:
		m.ResetGlobalEnabled()
		return nil
	case gitproject.FieldGlobalConfig:
		m.ResetGlobalConfig()
		return nil
	}
	return fmt.Errorf("unknown GitProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.changelogs != nil {
		edges = append(edges, gitproject.EdgeChangelogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gitproject.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.changelogs))
		for id := range m.changelogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchangelogs != nil {
		edges = append(edges, gitproject.EdgeChangelogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gitproject.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.removedchangelogs))
		for id := range m.removedchangelogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchangelogs {
		edges = append(edges, gitproject.EdgeChangelogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case gitproject.EdgeChangelogs:
		return m.clearedchangelogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GitProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitProjectMutation) ResetEdge(name string) error {
	switch name {
	case gitproject.EdgeChangelogs:
		m.ResetChangelogs()
		return nil
	}
	return fmt.Errorf("unknown GitProject edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	image_pull_secrets       *[]string
	appendimage_pull_secrets []string
	clearedFields            map[string]struct{}
	projects                 map[int]struct{}
	removedprojects          map[int]struct{}
	clearedprojects          bool
	done                     bool
	oldValue                 func(context.Context) (*Namespace, error)
	predicates               []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id int) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NamespaceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NamespaceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NamespaceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[namespace.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NamespaceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[namespace.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NamespaceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, namespace.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// SetImagePullSecrets sets the "image_pull_secrets" field.
func (m *NamespaceMutation) SetImagePullSecrets(s []string) {
	m.image_pull_secrets = &s
	m.appendimage_pull_secrets = nil
}

// ImagePullSecrets returns the value of the "image_pull_secrets" field in the mutation.
func (m *NamespaceMutation) ImagePullSecrets() (r []string, exists bool) {
	v := m.image_pull_secrets
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePullSecrets returns the old "image_pull_secrets" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldImagePullSecrets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePullSecrets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePullSecrets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePullSecrets: %w", err)
	}
	return oldValue.ImagePullSecrets, nil
}

// AppendImagePullSecrets adds s to the "image_pull_secrets" field.
func (m *NamespaceMutation) AppendImagePullSecrets(s []string) {
	m.appendimage_pull_secrets = append(m.appendimage_pull_secrets, s...)
}

// AppendedImagePullSecrets returns the list of values that were appended to the "image_pull_secrets" field in this mutation.
func (m *NamespaceMutation) AppendedImagePullSecrets() ([]string, bool) {
	if len(m.appendimage_pull_secrets) == 0 {
		return nil, false
	}
	return m.appendimage_pull_secrets, true
}

// ResetImagePullSecrets resets all changes to the "image_pull_secrets" field.
func (m *NamespaceMutation) ResetImagePullSecrets() {
	m.image_pull_secrets = nil
	m.appendimage_pull_secrets = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *NamespaceMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *NamespaceMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *NamespaceMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *NamespaceMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *NamespaceMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *NamespaceMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *NamespaceMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Namespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, namespace.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	if m.image_pull_secrets != nil {
		fields = append(fields, namespace.FieldImagePullSecrets)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespace.FieldDeletedAt:
		return m.DeletedAt()
	case namespace.FieldName:
		return m.Name()
	case namespace.FieldImagePullSecrets:
		return m.ImagePullSecrets()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespace.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case namespace.FieldName:
		return m.OldName(ctx)
	case namespace.FieldImagePullSecrets:
		return m.OldImagePullSecrets(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespace.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case namespace.FieldImagePullSecrets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePullSecrets(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(namespace.FieldDeletedAt) {
		fields = append(fields, namespace.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	switch name {
	case namespace.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespace.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case namespace.FieldName:
		m.ResetName()
		return nil
	case namespace.FieldImagePullSecrets:
		m.ResetImagePullSecrets()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, namespace.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, namespace.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, namespace.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	git_project_id           *int
	addgit_project_id        *int
	git_branch               *string
	git_commit               *string
	_config                  *string
	override_values          *string
	docker_image             *[]string
	appenddocker_image       []string
	pod_selectors            *[]string
	appendpod_selectors      []string
	atomic                   *bool
	deploy_status            *types.Deploy
	adddeploy_status         *types.Deploy
	env_values               *[]*types.KeyValue
	appendenv_values         []*types.KeyValue
	extra_values             *[]*types.ExtraValue
	appendextra_values       []*types.ExtraValue
	final_extra_values       *[]string
	appendfinal_extra_values []string
	version                  *int
	addversion               *int
	config_type              *string
	manifest                 *[]string
	appendmanifest           []string
	git_commit_web_url       *string
	git_commit_title         *string
	git_commit_author        *string
	git_commit_date          *time.Time
	clearedFields            map[string]struct{}
	changelogs               map[int]struct{}
	removedchangelogs        map[int]struct{}
	clearedchangelogs        bool
	namespace                *int
	clearednamespace         bool
	done                     bool
	oldValue                 func(context.Context) (*Project, error)
	predicates               []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetGitProjectID sets the "git_project_id" field.
func (m *ProjectMutation) SetGitProjectID(i int) {
	m.git_project_id = &i
	m.addgit_project_id = nil
}

// GitProjectID returns the value of the "git_project_id" field in the mutation.
func (m *ProjectMutation) GitProjectID() (r int, exists bool) {
	v := m.git_project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectID returns the old "git_project_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectID: %w", err)
	}
	return oldValue.GitProjectID, nil
}

// AddGitProjectID adds i to the "git_project_id" field.
func (m *ProjectMutation) AddGitProjectID(i int) {
	if m.addgit_project_id != nil {
		*m.addgit_project_id += i
	} else {
		m.addgit_project_id = &i
	}
}

// AddedGitProjectID returns the value that was added to the "git_project_id" field in this mutation.
func (m *ProjectMutation) AddedGitProjectID() (r int, exists bool) {
	v := m.addgit_project_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGitProjectID resets all changes to the "git_project_id" field.
func (m *ProjectMutation) ResetGitProjectID() {
	m.git_project_id = nil
	m.addgit_project_id = nil
}

// SetGitBranch sets the "git_branch" field.
func (m *ProjectMutation) SetGitBranch(s string) {
	m.git_branch = &s
}

// GitBranch returns the value of the "git_branch" field in the mutation.
func (m *ProjectMutation) GitBranch() (r string, exists bool) {
	v := m.git_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldGitBranch returns the old "git_branch" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitBranch: %w", err)
	}
	return oldValue.GitBranch, nil
}

// ResetGitBranch resets all changes to the "git_branch" field.
func (m *ProjectMutation) ResetGitBranch() {
	m.git_branch = nil
}

// SetGitCommit sets the "git_commit" field.
func (m *ProjectMutation) SetGitCommit(s string) {
	m.git_commit = &s
}

// GitCommit returns the value of the "git_commit" field in the mutation.
func (m *ProjectMutation) GitCommit() (r string, exists bool) {
	v := m.git_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommit returns the old "git_commit" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommit: %w", err)
	}
	return oldValue.GitCommit, nil
}

// ResetGitCommit resets all changes to the "git_commit" field.
func (m *ProjectMutation) ResetGitCommit() {
	m.git_commit = nil
}

// SetConfig sets the "config" field.
func (m *ProjectMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *ProjectMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *ProjectMutation) ResetConfig() {
	m._config = nil
}

// SetOverrideValues sets the "override_values" field.
func (m *ProjectMutation) SetOverrideValues(s string) {
	m.override_values = &s
}

// OverrideValues returns the value of the "override_values" field in the mutation.
func (m *ProjectMutation) OverrideValues() (r string, exists bool) {
	v := m.override_values
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideValues returns the old "override_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldOverrideValues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideValues: %w", err)
	}
	return oldValue.OverrideValues, nil
}

// ResetOverrideValues resets all changes to the "override_values" field.
func (m *ProjectMutation) ResetOverrideValues() {
	m.override_values = nil
}

// SetDockerImage sets the "docker_image" field.
func (m *ProjectMutation) SetDockerImage(s []string) {
	m.docker_image = &s
	m.appenddocker_image = nil
}

// DockerImage returns the value of the "docker_image" field in the mutation.
func (m *ProjectMutation) DockerImage() (r []string, exists bool) {
	v := m.docker_image
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerImage returns the old "docker_image" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDockerImage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerImage: %w", err)
	}
	return oldValue.DockerImage, nil
}

// AppendDockerImage adds s to the "docker_image" field.
func (m *ProjectMutation) AppendDockerImage(s []string) {
	m.appenddocker_image = append(m.appenddocker_image, s...)
}

// AppendedDockerImage returns the list of values that were appended to the "docker_image" field in this mutation.
func (m *ProjectMutation) AppendedDockerImage() ([]string, bool) {
	if len(m.appenddocker_image) == 0 {
		return nil, false
	}
	return m.appenddocker_image, true
}

// ResetDockerImage resets all changes to the "docker_image" field.
func (m *ProjectMutation) ResetDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
}

// SetPodSelectors sets the "pod_selectors" field.
func (m *ProjectMutation) SetPodSelectors(s []string) {
	m.pod_selectors = &s
	m.appendpod_selectors = nil
}

// PodSelectors returns the value of the "pod_selectors" field in the mutation.
func (m *ProjectMutation) PodSelectors() (r []string, exists bool) {
	v := m.pod_selectors
	if v == nil {
		return
	}
	return *v, true
}

// OldPodSelectors returns the old "pod_selectors" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPodSelectors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPodSelectors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPodSelectors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodSelectors: %w", err)
	}
	return oldValue.PodSelectors, nil
}

// AppendPodSelectors adds s to the "pod_selectors" field.
func (m *ProjectMutation) AppendPodSelectors(s []string) {
	m.appendpod_selectors = append(m.appendpod_selectors, s...)
}

// AppendedPodSelectors returns the list of values that were appended to the "pod_selectors" field in this mutation.
func (m *ProjectMutation) AppendedPodSelectors() ([]string, bool) {
	if len(m.appendpod_selectors) == 0 {
		return nil, false
	}
	return m.appendpod_selectors, true
}

// ResetPodSelectors resets all changes to the "pod_selectors" field.
func (m *ProjectMutation) ResetPodSelectors() {
	m.pod_selectors = nil
	m.appendpod_selectors = nil
}

// SetAtomic sets the "atomic" field.
func (m *ProjectMutation) SetAtomic(b bool) {
	m.atomic = &b
}

// Atomic returns the value of the "atomic" field in the mutation.
func (m *ProjectMutation) Atomic() (r bool, exists bool) {
	v := m.atomic
	if v == nil {
		return
	}
	return *v, true
}

// OldAtomic returns the old "atomic" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAtomic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtomic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtomic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtomic: %w", err)
	}
	return oldValue.Atomic, nil
}

// ResetAtomic resets all changes to the "atomic" field.
func (m *ProjectMutation) ResetAtomic() {
	m.atomic = nil
}

// SetDeployStatus sets the "deploy_status" field.
func (m *ProjectMutation) SetDeployStatus(t types.Deploy) {
	m.deploy_status = &t
	m.adddeploy_status = nil
}

// DeployStatus returns the value of the "deploy_status" field in the mutation.
func (m *ProjectMutation) DeployStatus() (r types.Deploy, exists bool) {
	v := m.deploy_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployStatus returns the old "deploy_status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeployStatus(ctx context.Context) (v types.Deploy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployStatus: %w", err)
	}
	return oldValue.DeployStatus, nil
}

// AddDeployStatus adds t to the "deploy_status" field.
func (m *ProjectMutation) AddDeployStatus(t types.Deploy) {
	if m.adddeploy_status != nil {
		*m.adddeploy_status += t
	} else {
		m.adddeploy_status = &t
	}
}

// AddedDeployStatus returns the value that was added to the "deploy_status" field in this mutation.
func (m *ProjectMutation) AddedDeployStatus() (r types.Deploy, exists bool) {
	v := m.adddeploy_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeployStatus resets all changes to the "deploy_status" field.
func (m *ProjectMutation) ResetDeployStatus() {
	m.deploy_status = nil
	m.adddeploy_status = nil
}

// SetEnvValues sets the "env_values" field.
func (m *ProjectMutation) SetEnvValues(tv []*types.KeyValue) {
	m.env_values = &tv
	m.appendenv_values = nil
}

// EnvValues returns the value of the "env_values" field in the mutation.
func (m *ProjectMutation) EnvValues() (r []*types.KeyValue, exists bool) {
	v := m.env_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvValues returns the old "env_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEnvValues(ctx context.Context) (v []*types.KeyValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvValues: %w", err)
	}
	return oldValue.EnvValues, nil
}

// AppendEnvValues adds tv to the "env_values" field.
func (m *ProjectMutation) AppendEnvValues(tv []*types.KeyValue) {
	m.appendenv_values = append(m.appendenv_values, tv...)
}

// AppendedEnvValues returns the list of values that were appended to the "env_values" field in this mutation.
func (m *ProjectMutation) AppendedEnvValues() ([]*types.KeyValue, bool) {
	if len(m.appendenv_values) == 0 {
		return nil, false
	}
	return m.appendenv_values, true
}

// ResetEnvValues resets all changes to the "env_values" field.
func (m *ProjectMutation) ResetEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
}

// SetExtraValues sets the "extra_values" field.
func (m *ProjectMutation) SetExtraValues(tv []*types.ExtraValue) {
	m.extra_values = &tv
	m.appendextra_values = nil
}

// ExtraValues returns the value of the "extra_values" field in the mutation.
func (m *ProjectMutation) ExtraValues() (r []*types.ExtraValue, exists bool) {
	v := m.extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraValues returns the old "extra_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldExtraValues(ctx context.Context) (v []*types.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraValues: %w", err)
	}
	return oldValue.ExtraValues, nil
}

// AppendExtraValues adds tv to the "extra_values" field.
func (m *ProjectMutation) AppendExtraValues(tv []*types.ExtraValue) {
	m.appendextra_values = append(m.appendextra_values, tv...)
}

// AppendedExtraValues returns the list of values that were appended to the "extra_values" field in this mutation.
func (m *ProjectMutation) AppendedExtraValues() ([]*types.ExtraValue, bool) {
	if len(m.appendextra_values) == 0 {
		return nil, false
	}
	return m.appendextra_values, true
}

// ResetExtraValues resets all changes to the "extra_values" field.
func (m *ProjectMutation) ResetExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
}

// SetFinalExtraValues sets the "final_extra_values" field.
func (m *ProjectMutation) SetFinalExtraValues(s []string) {
	m.final_extra_values = &s
	m.appendfinal_extra_values = nil
}

// FinalExtraValues returns the value of the "final_extra_values" field in the mutation.
func (m *ProjectMutation) FinalExtraValues() (r []string, exists bool) {
	v := m.final_extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalExtraValues returns the old "final_extra_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldFinalExtraValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalExtraValues: %w", err)
	}
	return oldValue.FinalExtraValues, nil
}

// AppendFinalExtraValues adds s to the "final_extra_values" field.
func (m *ProjectMutation) AppendFinalExtraValues(s []string) {
	m.appendfinal_extra_values = append(m.appendfinal_extra_values, s...)
}

// AppendedFinalExtraValues returns the list of values that were appended to the "final_extra_values" field in this mutation.
func (m *ProjectMutation) AppendedFinalExtraValues() ([]string, bool) {
	if len(m.appendfinal_extra_values) == 0 {
		return nil, false
	}
	return m.appendfinal_extra_values, true
}

// ResetFinalExtraValues resets all changes to the "final_extra_values" field.
func (m *ProjectMutation) ResetFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
}

// SetVersion sets the "version" field.
func (m *ProjectMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ProjectMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ProjectMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ProjectMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ProjectMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetConfigType sets the "config_type" field.
func (m *ProjectMutation) SetConfigType(s string) {
	m.config_type = &s
}

// ConfigType returns the value of the "config_type" field in the mutation.
func (m *ProjectMutation) ConfigType() (r string, exists bool) {
	v := m.config_type
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigType returns the old "config_type" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldConfigType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigType: %w", err)
	}
	return oldValue.ConfigType, nil
}

// ClearConfigType clears the value of the "config_type" field.
func (m *ProjectMutation) ClearConfigType() {
	m.config_type = nil
	m.clearedFields[project.FieldConfigType] = struct{}{}
}

// ConfigTypeCleared returns if the "config_type" field was cleared in this mutation.
func (m *ProjectMutation) ConfigTypeCleared() bool {
	_, ok := m.clearedFields[project.FieldConfigType]
	return ok
}

// ResetConfigType resets all changes to the "config_type" field.
func (m *ProjectMutation) ResetConfigType() {
	m.config_type = nil
	delete(m.clearedFields, project.FieldConfigType)
}

// SetManifest sets the "manifest" field.
func (m *ProjectMutation) SetManifest(s []string) {
	m.manifest = &s
	m.appendmanifest = nil
}

// Manifest returns the value of the "manifest" field in the mutation.
func (m *ProjectMutation) Manifest() (r []string, exists bool) {
	v := m.manifest
	if v == nil {
		return
	}
	return *v, true
}

// OldManifest returns the old "manifest" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldManifest(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifest: %w", err)
	}
	return oldValue.Manifest, nil
}

// AppendManifest adds s to the "manifest" field.
func (m *ProjectMutation) AppendManifest(s []string) {
	m.appendmanifest = append(m.appendmanifest, s...)
}

// AppendedManifest returns the list of values that were appended to the "manifest" field in this mutation.
func (m *ProjectMutation) AppendedManifest() ([]string, bool) {
	if len(m.appendmanifest) == 0 {
		return nil, false
	}
	return m.appendmanifest, true
}

// ResetManifest resets all changes to the "manifest" field.
func (m *ProjectMutation) ResetManifest() {
	m.manifest = nil
	m.appendmanifest = nil
}

// SetGitCommitWebURL sets the "git_commit_web_url" field.
func (m *ProjectMutation) SetGitCommitWebURL(s string) {
	m.git_commit_web_url = &s
}

// GitCommitWebURL returns the value of the "git_commit_web_url" field in the mutation.
func (m *ProjectMutation) GitCommitWebURL() (r string, exists bool) {
	v := m.git_commit_web_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitWebURL returns the old "git_commit_web_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitWebURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitWebURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitWebURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitWebURL: %w", err)
	}
	return oldValue.GitCommitWebURL, nil
}

// ResetGitCommitWebURL resets all changes to the "git_commit_web_url" field.
func (m *ProjectMutation) ResetGitCommitWebURL() {
	m.git_commit_web_url = nil
}

// SetGitCommitTitle sets the "git_commit_title" field.
func (m *ProjectMutation) SetGitCommitTitle(s string) {
	m.git_commit_title = &s
}

// GitCommitTitle returns the value of the "git_commit_title" field in the mutation.
func (m *ProjectMutation) GitCommitTitle() (r string, exists bool) {
	v := m.git_commit_title
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitTitle returns the old "git_commit_title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitTitle: %w", err)
	}
	return oldValue.GitCommitTitle, nil
}

// ResetGitCommitTitle resets all changes to the "git_commit_title" field.
func (m *ProjectMutation) ResetGitCommitTitle() {
	m.git_commit_title = nil
}

// SetGitCommitAuthor sets the "git_commit_author" field.
func (m *ProjectMutation) SetGitCommitAuthor(s string) {
	m.git_commit_author = &s
}

// GitCommitAuthor returns the value of the "git_commit_author" field in the mutation.
func (m *ProjectMutation) GitCommitAuthor() (r string, exists bool) {
	v := m.git_commit_author
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitAuthor returns the old "git_commit_author" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitAuthor: %w", err)
	}
	return oldValue.GitCommitAuthor, nil
}

// ResetGitCommitAuthor resets all changes to the "git_commit_author" field.
func (m *ProjectMutation) ResetGitCommitAuthor() {
	m.git_commit_author = nil
}

// SetGitCommitDate sets the "git_commit_date" field.
func (m *ProjectMutation) SetGitCommitDate(t time.Time) {
	m.git_commit_date = &t
}

// GitCommitDate returns the value of the "git_commit_date" field in the mutation.
func (m *ProjectMutation) GitCommitDate() (r time.Time, exists bool) {
	v := m.git_commit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitDate returns the old "git_commit_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitDate: %w", err)
	}
	return oldValue.GitCommitDate, nil
}

// ClearGitCommitDate clears the value of the "git_commit_date" field.
func (m *ProjectMutation) ClearGitCommitDate() {
	m.git_commit_date = nil
	m.clearedFields[project.FieldGitCommitDate] = struct{}{}
}

// GitCommitDateCleared returns if the "git_commit_date" field was cleared in this mutation.
func (m *ProjectMutation) GitCommitDateCleared() bool {
	_, ok := m.clearedFields[project.FieldGitCommitDate]
	return ok
}

// ResetGitCommitDate resets all changes to the "git_commit_date" field.
func (m *ProjectMutation) ResetGitCommitDate() {
	m.git_commit_date = nil
	delete(m.clearedFields, project.FieldGitCommitDate)
}

// SetNamespaceID sets the "namespace_id" field.
func (m *ProjectMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *ProjectMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ClearNamespaceID clears the value of the "namespace_id" field.
func (m *ProjectMutation) ClearNamespaceID() {
	m.namespace = nil
	m.clearedFields[project.FieldNamespaceID] = struct{}{}
}

// NamespaceIDCleared returns if the "namespace_id" field was cleared in this mutation.
func (m *ProjectMutation) NamespaceIDCleared() bool {
	_, ok := m.clearedFields[project.FieldNamespaceID]
	return ok
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *ProjectMutation) ResetNamespaceID() {
	m.namespace = nil
	delete(m.clearedFields, project.FieldNamespaceID)
}

// AddChangelogIDs adds the "changelogs" edge to the Changelog entity by ids.
func (m *ProjectMutation) AddChangelogIDs(ids ...int) {
	if m.changelogs == nil {
		m.changelogs = make(map[int]struct{})
	}
	for i := range ids {
		m.changelogs[ids[i]] = struct{}{}
	}
}

// ClearChangelogs clears the "changelogs" edge to the Changelog entity.
func (m *ProjectMutation) ClearChangelogs() {
	m.clearedchangelogs = true
}

// ChangelogsCleared reports if the "changelogs" edge to the Changelog entity was cleared.
func (m *ProjectMutation) ChangelogsCleared() bool {
	return m.clearedchangelogs
}

// RemoveChangelogIDs removes the "changelogs" edge to the Changelog entity by IDs.
func (m *ProjectMutation) RemoveChangelogIDs(ids ...int) {
	if m.removedchangelogs == nil {
		m.removedchangelogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.changelogs, ids[i])
		m.removedchangelogs[ids[i]] = struct{}{}
	}
}

// RemovedChangelogs returns the removed IDs of the "changelogs" edge to the Changelog entity.
func (m *ProjectMutation) RemovedChangelogsIDs() (ids []int) {
	for id := range m.removedchangelogs {
		ids = append(ids, id)
	}
	return
}

// ChangelogsIDs returns the "changelogs" edge IDs in the mutation.
func (m *ProjectMutation) ChangelogsIDs() (ids []int) {
	for id := range m.changelogs {
		ids = append(ids, id)
	}
	return
}

// ResetChangelogs resets all changes to the "changelogs" edge.
func (m *ProjectMutation) ResetChangelogs() {
	m.changelogs = nil
	m.clearedchangelogs = false
	m.removedchangelogs = nil
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *ProjectMutation) ClearNamespace() {
	m.clearednamespace = true
	m.clearedFields[project.FieldNamespaceID] = struct{}{}
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *ProjectMutation) NamespaceCleared() bool {
	return m.NamespaceIDCleared() || m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *ProjectMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.git_project_id != nil {
		fields = append(fields, project.FieldGitProjectID)
	}
	if m.git_branch != nil {
		fields = append(fields, project.FieldGitBranch)
	}
	if m.git_commit != nil {
		fields = append(fields, project.FieldGitCommit)
	}
	if m._config != nil {
		fields = append(fields, project.FieldConfig)
	}
	if m.override_values != nil {
		fields = append(fields, project.FieldOverrideValues)
	}
	if m.docker_image != nil {
		fields = append(fields, project.FieldDockerImage)
	}
	if m.pod_selectors != nil {
		fields = append(fields, project.FieldPodSelectors)
	}
	if m.atomic != nil {
		fields = append(fields, project.FieldAtomic)
	}
	if m.deploy_status != nil {
		fields = append(fields, project.FieldDeployStatus)
	}
	if m.env_values != nil {
		fields = append(fields, project.FieldEnvValues)
	}
	if m.extra_values != nil {
		fields = append(fields, project.FieldExtraValues)
	}
	if m.final_extra_values != nil {
		fields = append(fields, project.FieldFinalExtraValues)
	}
	if m.version != nil {
		fields = append(fields, project.FieldVersion)
	}
	if m.config_type != nil {
		fields = append(fields, project.FieldConfigType)
	}
	if m.manifest != nil {
		fields = append(fields, project.FieldManifest)
	}
	if m.git_commit_web_url != nil {
		fields = append(fields, project.FieldGitCommitWebURL)
	}
	if m.git_commit_title != nil {
		fields = append(fields, project.FieldGitCommitTitle)
	}
	if m.git_commit_author != nil {
		fields = append(fields, project.FieldGitCommitAuthor)
	}
	if m.git_commit_date != nil {
		fields = append(fields, project.FieldGitCommitDate)
	}
	if m.namespace != nil {
		fields = append(fields, project.FieldNamespaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldGitProjectID:
		return m.GitProjectID()
	case project.FieldGitBranch:
		return m.GitBranch()
	case project.FieldGitCommit:
		return m.GitCommit()
	case project.FieldConfig:
		return m.Config()
	case project.FieldOverrideValues:
		return m.OverrideValues()
	case project.FieldDockerImage:
		return m.DockerImage()
	case project.FieldPodSelectors:
		return m.PodSelectors()
	case project.FieldAtomic:
		return m.Atomic()
	case project.FieldDeployStatus:
		return m.DeployStatus()
	case project.FieldEnvValues:
		return m.EnvValues()
	case project.FieldExtraValues:
		return m.ExtraValues()
	case project.FieldFinalExtraValues:
		return m.FinalExtraValues()
	case project.FieldVersion:
		return m.Version()
	case project.FieldConfigType:
		return m.ConfigType()
	case project.FieldManifest:
		return m.Manifest()
	case project.FieldGitCommitWebURL:
		return m.GitCommitWebURL()
	case project.FieldGitCommitTitle:
		return m.GitCommitTitle()
	case project.FieldGitCommitAuthor:
		return m.GitCommitAuthor()
	case project.FieldGitCommitDate:
		return m.GitCommitDate()
	case project.FieldNamespaceID:
		return m.NamespaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldGitProjectID:
		return m.OldGitProjectID(ctx)
	case project.FieldGitBranch:
		return m.OldGitBranch(ctx)
	case project.FieldGitCommit:
		return m.OldGitCommit(ctx)
	case project.FieldConfig:
		return m.OldConfig(ctx)
	case project.FieldOverrideValues:
		return m.OldOverrideValues(ctx)
	case project.FieldDockerImage:
		return m.OldDockerImage(ctx)
	case project.FieldPodSelectors:
		return m.OldPodSelectors(ctx)
	case project.FieldAtomic:
		return m.OldAtomic(ctx)
	case project.FieldDeployStatus:
		return m.OldDeployStatus(ctx)
	case project.FieldEnvValues:
		return m.OldEnvValues(ctx)
	case project.FieldExtraValues:
		return m.OldExtraValues(ctx)
	case project.FieldFinalExtraValues:
		return m.OldFinalExtraValues(ctx)
	case project.FieldVersion:
		return m.OldVersion(ctx)
	case project.FieldConfigType:
		return m.OldConfigType(ctx)
	case project.FieldManifest:
		return m.OldManifest(ctx)
	case project.FieldGitCommitWebURL:
		return m.OldGitCommitWebURL(ctx)
	case project.FieldGitCommitTitle:
		return m.OldGitCommitTitle(ctx)
	case project.FieldGitCommitAuthor:
		return m.OldGitCommitAuthor(ctx)
	case project.FieldGitCommitDate:
		return m.OldGitCommitDate(ctx)
	case project.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectID(v)
		return nil
	case project.FieldGitBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitBranch(v)
		return nil
	case project.FieldGitCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommit(v)
		return nil
	case project.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case project.FieldOverrideValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideValues(v)
		return nil
	case project.FieldDockerImage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerImage(v)
		return nil
	case project.FieldPodSelectors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodSelectors(v)
		return nil
	case project.FieldAtomic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtomic(v)
		return nil
	case project.FieldDeployStatus:
		v, ok := value.(types.Deploy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployStatus(v)
		return nil
	case project.FieldEnvValues:
		v, ok := value.([]*types.KeyValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvValues(v)
		return nil
	case project.FieldExtraValues:
		v, ok := value.([]*types.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraValues(v)
		return nil
	case project.FieldFinalExtraValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalExtraValues(v)
		return nil
	case project.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case project.FieldConfigType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigType(v)
		return nil
	case project.FieldManifest:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifest(v)
		return nil
	case project.FieldGitCommitWebURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitWebURL(v)
		return nil
	case project.FieldGitCommitTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitTitle(v)
		return nil
	case project.FieldGitCommitAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitAuthor(v)
		return nil
	case project.FieldGitCommitDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitDate(v)
		return nil
	case project.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addgit_project_id != nil {
		fields = append(fields, project.FieldGitProjectID)
	}
	if m.adddeploy_status != nil {
		fields = append(fields, project.FieldDeployStatus)
	}
	if m.addversion != nil {
		fields = append(fields, project.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldGitProjectID:
		return m.AddedGitProjectID()
	case project.FieldDeployStatus:
		return m.AddedDeployStatus()
	case project.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGitProjectID(v)
		return nil
	case project.FieldDeployStatus:
		v, ok := value.(types.Deploy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeployStatus(v)
		return nil
	case project.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.FieldCleared(project.FieldConfigType) {
		fields = append(fields, project.FieldConfigType)
	}
	if m.FieldCleared(project.FieldGitCommitDate) {
		fields = append(fields, project.FieldGitCommitDate)
	}
	if m.FieldCleared(project.FieldNamespaceID) {
		fields = append(fields, project.FieldNamespaceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case project.FieldConfigType:
		m.ClearConfigType()
		return nil
	case project.FieldGitCommitDate:
		m.ClearGitCommitDate()
		return nil
	case project.FieldNamespaceID:
		m.ClearNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldGitProjectID:
		m.ResetGitProjectID()
		return nil
	case project.FieldGitBranch:
		m.ResetGitBranch()
		return nil
	case project.FieldGitCommit:
		m.ResetGitCommit()
		return nil
	case project.FieldConfig:
		m.ResetConfig()
		return nil
	case project.FieldOverrideValues:
		m.ResetOverrideValues()
		return nil
	case project.FieldDockerImage:
		m.ResetDockerImage()
		return nil
	case project.FieldPodSelectors:
		m.ResetPodSelectors()
		return nil
	case project.FieldAtomic:
		m.ResetAtomic()
		return nil
	case project.FieldDeployStatus:
		m.ResetDeployStatus()
		return nil
	case project.FieldEnvValues:
		m.ResetEnvValues()
		return nil
	case project.FieldExtraValues:
		m.ResetExtraValues()
		return nil
	case project.FieldFinalExtraValues:
		m.ResetFinalExtraValues()
		return nil
	case project.FieldVersion:
		m.ResetVersion()
		return nil
	case project.FieldConfigType:
		m.ResetConfigType()
		return nil
	case project.FieldManifest:
		m.ResetManifest()
		return nil
	case project.FieldGitCommitWebURL:
		m.ResetGitCommitWebURL()
		return nil
	case project.FieldGitCommitTitle:
		m.ResetGitCommitTitle()
		return nil
	case project.FieldGitCommitAuthor:
		m.ResetGitCommitAuthor()
		return nil
	case project.FieldGitCommitDate:
		m.ResetGitCommitDate()
		return nil
	case project.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.changelogs != nil {
		edges = append(edges, project.EdgeChangelogs)
	}
	if m.namespace != nil {
		edges = append(edges, project.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.changelogs))
		for id := range m.changelogs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchangelogs != nil {
		edges = append(edges, project.EdgeChangelogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.removedchangelogs))
		for id := range m.removedchangelogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchangelogs {
		edges = append(edges, project.EdgeChangelogs)
	}
	if m.clearednamespace {
		edges = append(edges, project.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeChangelogs:
		return m.clearedchangelogs
	case project.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeChangelogs:
		m.ResetChangelogs()
		return nil
	case project.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}
